#
# Рассмотрим способы создания циклов в Python.
# Важно! Мы снова будем использовать отступы в 4 пробела. Это неотъемлемая часть
# синтаксиса языка.
#
# ----------------------------------------------------------------------------
# Логический цикл while
# ----------------------------------------------------------------------------
#
# Цикл while является циклом с предусловием. Проверяем логическое условие,
# аналогично "если" и в случае истинности выполняем вложенный блок кода. Далее
# возвращаемся к проверке условия.
# Попробуем перебрать всё чётные числа от нуля до введённого пользователем
# исключительно..
num = float(input('Введите число: '))
count = 0
while count < num:
    print(count)
    count += 2

# Проверка условия после while и выполнение тела цикла продолжается до тех пор,
# пока условие истинно.
#
# Синтаксический сахар
# Обратите внимание на нижнюю строку кода. "+=" - синтаксический сахар Python.
# Синтаксический сахар (англ. syntactic sugar) в языке программирования — это
# синтаксические возможности, применение которых не влияет на поведение
# программы, но делает использование языка более удобным для человека.
# Для неизменяемых типов данных, а числа в Python неизменяемы, две следующие
# строки кода эквивалентны.
#
# num = num + 1
# num += 1
# num++  не работает в Python
#
# Аналогично можно записать коротко вычитание, умножение, целочисленное деление
# и другие операции.
# ----------------------------------------------------------------------------
# Возврат в начало цикла, continue
# ----------------------------------------------------------------------------
#
# При необходимости работу цикла можно прервать и досрочно вернуться к проверке
# условия. Для этого используем зарезервированное слово continue.
# Выведем все чётные числа (как в прошлом примере), кроме тех, которые кратны 12.
#
num = float(input('Введите число: '))
STEP = 2
limit = num - STEP
count = -STEP
while count < limit:
    count += STEP
    if count % 12 == 0:
        continue
    print(count)
# if внутри цикла проверяет кратность двенадцати. В случае истинности команда
# continue возвращает нас к началу цикла, к while.
# И пара слов о двух оптимизациях в коде:
#   1. STEP = 2 - добавили константу для движения по чётным и ушли от
#      "магических чисел". Теперь изменение условия на "вывод чисел кратных 5"
#      потребует # замены числа в одном месте кода.
#   2. Ввели переменную limit. Чтобы цикл не выводил лишние числа, больше
#      введенного num, на каждой проверке цикла while надо вычитать значение
#      шага. Но шаг - константа. Для экономии ресурсов ПК и ускорения работы
#      кода логично сделать вычитание один раз перед циклом и сравнивать
#      значения быстрее, без вычитания в строке while
#
# ----------------------------------------------------------------------------
# Досрочное завершение цикла, break
# ----------------------------------------------------------------------------
# Ещё один способ управления циклом - команда break для его досрочного
# завершения. Она отлично подходит для создания циклов с постусловием,
# бесконечных циклов с  возможностью выхода.
# Рассмотрим на примере программы, которая просит ввести число внутри
# заданного диапазона.
min_limit = 0
max_limit = 10
while True:
    print('Введи число между', min_limit, 'и', max_limit, '? ')
    num = float(input())
    if num < min_limit or num > max_limit:
        print('Неверно')
    else:
        break
print('Было введено число ' + str(num))
# Конструкция while True: создаёт бесконечный цикл. Вместо True можно было бы
# подставить любое выражение, которое всегда возвращает истину. Но именно
# такая реализация обеспечивает лучшую читаемость и быстродействие.
#
# ----------------------------------------------------------------------------
# Действие после цикла, else
# ----------------------------------------------------------------------------
#
# Зарезервированное слово else может применяться не только к ветвлениям, но и к
# циклам. Для этого else должно быть расположено на том же уровне, т.е. иметь
# столько же пробельных отступов, что и начало цикла - while.
# Доработаем прошлую программу и дадим 3 попытки на попадание в диапазон.
#
min_limit = 0
max_limit = 10
count = 3

while count > 0:
    print('Попытка ' + str(count))
    count -= 1

    num = float(input('Введи число между ' + str(min_limit) + ' и ' +
                      str(max_limit) + ': '))
    if num < min_limit or num > max_limit:
        print('Неверно')
    else:
        break

else:
    print('Исчерпаны все попытки. Сожалею.')
    quit()

print('Было введено число ' + str(num))

# Что изменилось в коде:
#   ● Добавили счётчик count. Цикл проверяет не уменьшился ли счётчик до нуля.
#     Если нет, переходим в тело цикла. Выводим значение счётчика на каждом
#     витке цикла и уменьшает его на единицу.
#   ● Добавили else для while. Логика следующая. Если пользователь ввёл
#     верное число и сработала команда break, блок else для цикла
#     игнорируется. А если числа вводились ошибочно, счётчик досчитал до нуля
#     и произошел выход из цикла по "лжи" в while. В этом случае сработает
#     блок кода после else для цикла. Если коротко, вызов break в цикле
#     игнорирует else для цикла.
#   ● quit() - ещё одна функция для завершения кода раньше, чем мы дойдём до
#     конца файла. Это вторая функция. Первой, exit() мы пользовались для
#     завершения работы сеанса интерпретатора. Работают они аналогично.
#   ● Мы добавили пустые строки в код. Python игнорирует такие строки. Но
#     разделение кода на блоки по смыслу упрощает чтение. Кроме того, на
#     следующих лекциях мы поговорим о пустых строках, которые прописаны в
#     PEP-8. Но не ставьте пустые строки после каждой строки кода. Если вам
#     нравится большой межстрочный интервал, настройте его в своей IDE.
#   ● PEP-8! Кстати, последняя строка в файле должны быть пустой. Именно одна,
#     а не ноль, и не две.
#
# ----------------------------------------------------------------------------
# Цикл итератор for in
# ----------------------------------------------------------------------------
#
# Цикл for in используется Python разработчиками намного чаще. Прежде чем
# приступить к его рассмотрению уточню, что команды continue, break и else
# могут применяться к циклу for in точно так же как и до этого в цикле while.
# Рассмотрим работу цикла в качестве итератора последовательности.
# Итерироваться будем по массиву с числами из части про ветвления и проверку
# на вхождение.
data = [0, 1, 1, 2, 3, 5, 8, 13, 21]
for item in data:
    print(item)

# Цикл последовательно перебирает все элементы массива data и поочерёдно
# помещает их в переменную item. После for указываем переменную или
# переменные для приема значений, они изменяются на каждом витке цикла.
# После in указываем объект, из которого последовательно берём данные.
# Важно! Нельзя изменять содержимое контейнера (в нашем примере data)
# во время итерации по нему, т.е. внутри цикла. Это приведет
# к неожиданным ошибкам.
# ----------------------------------------------------------------------------
# Цикл по целым числам, он же арифметический цикл,
# функция range()
# ----------------------------------------------------------------------------
#
# Для перебора целых чисел цикл for in используется в связке с функцией
# range(). Она выступает в качестве объекта итератора. Пример печати чётных
# чисел от нуля до введённого числа может выглядеть так с циклом for:
#
num = int(input('Введите число: '))
for i in range(0, num, 2):
    print(i)

# Важно! Аргументами функции range() должны быть целые числа, int()
#
# Рассмотрим подробнее варианты работы функции range(). Обратите внимание
# на количество переданных функции аргументов
#
# range(stop) - перебираем значения от нуля до stop исключительно
#               с шагом один
# range(start, stop) - перебираем значения от start включительно до stop
#               исключительно с шагом один
# range(start, stop, step) - перебираем значения от start включительно
#               до stop исключительно с шагом step.
# Пара если.
#   ● Если значение step отрицательное, перебор будет в сторону уменьшения.
#   ● Если start больше stop при положительном step или наоборот start меньше
#     stop при отрицательном step, цикл не сработает ни разу.
#     range(10, 5, 2) - ничего
#
